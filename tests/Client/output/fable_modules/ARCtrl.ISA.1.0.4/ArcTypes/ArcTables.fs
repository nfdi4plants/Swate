namespace ARCtrl.ISA

open System.Collections.Generic

module ArcTablesAux =

    ///// 👀 Please do not remove this here until i copied it to Swate ~Kevin F
    //let getNextAutoGeneratedTableName (existingNames: seq<string>) =
    //    let findNextNumber (numbers: int list) =
    //        let rec findNext current = function
    //            | [] -> current + 1
    //            | x::xs when x = current + 1 -> findNext x xs
    //            | _ -> current + 1

    //        match numbers with
    //        | [] -> 0
    //        | x::xs -> findNext x xs
    //    let existingNumbers = existingNames |> Seq.choose (fun x -> match x with | Regex.ActivePatterns.AutoGeneratedTableName n -> Some n| _ -> None) 
    //    let nextNumber =
    //        if Seq.isEmpty existingNumbers then
    //            1
    //        else
    //            existingNumbers
    //            |> Seq.sort
    //            |> List.ofSeq
    //            |> findNextNumber
    //    ArcTable.init($"New Table {nextNumber}")

    /// If a table with the given name exists in the TableList, returns it, else returns None.
    let tryFindIndexByTableName (name: string) (tables: ResizeArray<ArcTable>) =
        tables |> Seq.tryFindIndex (fun t -> t.Name = name)

    /// If a table with the given name exists in the TableList, returns it, else fails.
    let findIndexByTableName (name: string) (tables: ResizeArray<ArcTable>) =
        match tables |> Seq.tryFindIndex (fun t -> t.Name = name) with
        | Some index -> index
        | None -> failwith $"Unable to find table with name '{name}'!"

    /// Collects the IOType of each distinct entity in the tables. Then merges the IOType of each entity according to the IOType.Merge function.
    let getIOMap (tables: ResizeArray<ArcTable>) =
        let mappings : Dictionary<string,IOType> = Dictionary()
        let includeInMap (name : string) (ioType:IOType) = 
            if name <> "" then 
                match Aux.Dict.tryFind name mappings with
                | Some oldIOType -> 
                    let newIOType = oldIOType.Merge ioType
                    mappings.[name] <- newIOType
                | None ->
                    mappings.Add(name, ioType)
        for table in tables do
            
            match table.TryGetInputColumn() with
            | Some ic -> 
                let ioType = ic.Header.TryInput().Value
                ic.Cells
                |> Array.iter (fun c -> 
                    includeInMap (c.ToFreeTextCell().AsFreeText) ioType
                )
            | None -> ()
            match table.TryGetOutputColumn() with
            | Some oc -> 
                let ioType = oc.Header.TryOutput().Value
                oc.Cells
                |> Array.iter (fun c -> 
                    includeInMap (c.ToFreeTextCell().AsFreeText) ioType
                )
            | None -> ()
        mappings

    let applyIOMap (map : Dictionary<string,IOType>) (tables : ResizeArray<ArcTable>) = 
        for table in tables do
            match table.TryGetInputColumn() with
            | Some ic -> 
                let index = table.Headers |> Seq.findIndex (fun x -> x.isInput)
                let oldIoType = ic.Header.TryInput().Value
                let newIOType = 
                    ic.Cells
                    |> Array.fold (fun (io : IOType) c ->
                        match Aux.Dict.tryFind (c.ToFreeTextCell().AsFreeText) map with
                        | Some newIO -> io.Merge newIO
                        | None -> io
                    ) oldIoType
                table.UpdateHeader(index, CompositeHeader.Input(newIOType))
            | None -> ()
            match table.TryGetOutputColumn() with
            | Some oc -> 
                let index = table.Headers |> Seq.findIndex (fun x -> x.isOutput)
                let oldIoType = oc.Header.TryOutput().Value
                let newIOType = 
                    oc.Cells
                    |> Array.fold (fun (io : IOType) c ->
                        match Aux.Dict.tryFind (c.ToFreeTextCell().AsFreeText) map with
                        | Some newIO -> io.Merge newIO
                        | None -> io
                    ) oldIoType
                table.UpdateHeader(index, CompositeHeader.Output(newIOType))
            | None -> ()

    module SanityChecks =
        
        /// Fails, if the index is out of range of the Tables collection. When allowAppend is set to true, it may be out of range by at most 1. 
        let validateSheetIndex (index: int) (allowAppend: bool) (sheets: ResizeArray<ArcTable>) =
            let eval x y = if allowAppend then x > y else x >= y
            if index < 0 then failwith "Cannot insert ArcTable at index < 0."
            if eval index sheets.Count then failwith $"Specified index is out of range! Assay contains only {sheets.Count} tables."

        /// Fails, if two tables have the same name.
        let validateNamesUnique (names:seq<string>) =
            let isDistinct = (Seq.length names) = (Seq.distinct names |> Seq.length)
            if not isDistinct then 
                failwith "Cannot add multiple tables with the same name! Table names inside one assay must be unqiue"

        /// Fails, if the name is already used by another table.
        let validateNewNameUnique (newName:string) (existingNames:seq<string>) =
            match Seq.tryFindIndex (fun x -> x = newName) existingNames with
            | Some i ->
                failwith $"Cannot create table with name {newName}, as table names must be unique and table at index {i} has the same name."
            | None ->
                ()

        /// Fails, if the name is already used by another table at a different position.
        ///
        /// Does not fail, if the newName is the same as the one in the given position.
        let validateNewNameAtUnique (index : int) (newName:string) (existingNames:seq<string>) =
            match Seq.tryFindIndex (fun x -> x = newName) existingNames with
            | Some i when index = i-> ()
            | Some i -> 
                failwith $"Cannot create table with name {newName}, as table names must be unique and table at index {i} has the same name."
            | None ->
                ()

        let validateNewNamesUnique (newNames:seq<string>) (existingNames:seq<string>) =
            validateNamesUnique newNames
            let setNew = Set.ofSeq newNames
            let setOld = Set.ofSeq existingNames
            let same = Set.intersect setNew setOld
            if not same.IsEmpty then
                failwith $"Cannot create tables with the names {same}, as table names must be unique."

open ArcTablesAux
open ArcTableAux
open Fable.Core

/// This type only includes mutable options and only static members, the MUST be referenced and used in all record types implementing `ResizeArray<ArcTable>`
[<AttachMembers>]
type ArcTables(initTables:ResizeArray<ArcTable>) = 

    let mutable tables = initTables
    member this.Tables 
        with get() = tables
        and set(newTables) = tables <- newTables

    interface IEnumerable<ArcTable> with
        member this.GetEnumerator() : IEnumerator<ArcTable> =
            this.Tables.GetEnumerator()
        member this.GetEnumerator(): System.Collections.IEnumerator = 
            this.Tables.GetEnumerator()

    member this.Item 
        with get(index) = 
            this.Tables.[index] 

    member this.TableNames 
        with get() = 
            [for s in this.Tables do yield s.Name]

    member this.TableCount 
        with get() = this.Tables.Count

    // - Table API - //
    member this.AddTable(table:ArcTable, ?index: int) = 
        let index = defaultArg index this.TableCount
        SanityChecks.validateSheetIndex index true this.Tables
        SanityChecks.validateNewNameUnique table.Name this.TableNames
        this.Tables.Insert(index, table)

    // - Table API - //
    member this.AddTables(tables:seq<ArcTable>, ?index: int) = 
        let index = defaultArg index this.TableCount
        SanityChecks.validateSheetIndex index true this.Tables
        SanityChecks.validateNewNamesUnique (tables |> Seq.map (fun x -> x.Name)) this.TableNames
        this.Tables.InsertRange(index, tables)

    // - Table API - //
    member this.InitTable(tableName:string, ?index: int) = 
        let index = defaultArg index this.TableCount
        let table = ArcTable.init(tableName)
        SanityChecks.validateSheetIndex index true this.Tables
        SanityChecks.validateNewNameUnique table.Name this.TableNames
        this.Tables.Insert(index, table)
        table

    // - Table API - //
    member this.InitTables(tableNames:seq<string>, ?index: int) = 
        let index = defaultArg index this.TableCount
        let tables = tableNames |> Seq.map (fun x -> ArcTable.init(x))
        SanityChecks.validateSheetIndex index true this.Tables
        SanityChecks.validateNewNamesUnique (tables |> Seq.map (fun x -> x.Name)) this.TableNames
        this.Tables.InsertRange(index, tables)

    // - Table API - //
    member this.GetTableAt(index:int) : ArcTable =
        SanityChecks.validateSheetIndex index false this.Tables
        this.Tables.[index]

    // - Table API - //
    member this.GetTable(name: string) : ArcTable =
        findIndexByTableName name this.Tables
        |> this.GetTableAt

    // - Table API - //
    member this.UpdateTableAt(index:int, table:ArcTable) =
        SanityChecks.validateSheetIndex index false this.Tables
        SanityChecks.validateNewNameAtUnique index table.Name this.TableNames
        this.Tables.[index] <- table

    // - Table API - //
    member this.UpdateTable(name: string, table:ArcTable) : unit =
        (findIndexByTableName name this.Tables, table)
        |> this.UpdateTableAt

    // - Table API - //
    member this.SetTableAt(index:int, table:ArcTable) =
        SanityChecks.validateSheetIndex index true this.Tables
        SanityChecks.validateNewNameAtUnique index table.Name this.TableNames
        this.Tables.[index] <- table

    // - Table API - //
    member this.SetTable(name: string, table:ArcTable) : unit =
        match tryFindIndexByTableName name this.Tables with
        | Some index -> this.SetTableAt(index, table)
        | None -> this.AddTable(table)

    // - Table API - //
    member this.RemoveTableAt(index:int) : unit =
        SanityChecks.validateSheetIndex index false this.Tables
        this.Tables.RemoveAt(index)

    // - Table API - //
    member this.RemoveTable(name: string) : unit =
        findIndexByTableName name this.Tables
        |> this.RemoveTableAt


    // - Table API - //
    // Remark: This must stay `ArcTable -> unit` so name cannot be changed here.
    member this.MapTableAt(index: int, updateFun: ArcTable -> unit) =
        SanityChecks.validateSheetIndex index false this.Tables
        let table = this.Tables.[index]
        updateFun table

    // - Table API - //
    member this.MapTable(name: string, updateFun: ArcTable -> unit) : unit =
        (findIndexByTableName name this.Tables, updateFun)
        |> this.MapTableAt

    // - Table API - //
    member this.RenameTableAt(index: int, newName: string) : unit =
        SanityChecks.validateSheetIndex index false this.Tables
        SanityChecks.validateNewNameUnique newName this.TableNames
        let table = this.GetTableAt index
        table.Name <- newName

    // - Table API - //
    member this.RenameTable(name: string, newName: string) : unit =
        (findIndexByTableName name this.Tables, newName)
        |> this.RenameTableAt

    // - Column CRUD API - //
    member this.AddColumnAt(tableIndex:int, header: CompositeHeader, ?cells: CompositeCell [], ?columnIndex: int, ?forceReplace: bool) = 
        this.MapTableAt(tableIndex, fun table ->
            table.AddColumn(header, ?cells=cells, ?index=columnIndex, ?forceReplace=forceReplace)
        )

    // - Column CRUD API - //
    member this.AddColumn(tableName: string, header: CompositeHeader, ?cells: CompositeCell [], ?columnIndex: int, ?forceReplace: bool) =
        findIndexByTableName tableName this.Tables
        |> fun i -> this.AddColumnAt(i, header, ?cells=cells, ?columnIndex=columnIndex, ?forceReplace=forceReplace)

    // - Column CRUD API - //
    member this.RemoveColumnAt(tableIndex: int, columnIndex: int) =
        this.MapTableAt(tableIndex, fun table ->
            table.RemoveColumn(columnIndex)
        )

    // - Column CRUD API - //
    member this.RemoveColumn(tableName: string, columnIndex: int) : unit =
        (findIndexByTableName tableName this.Tables, columnIndex)
        |> this.RemoveColumnAt

    // - Column CRUD API - //
    member this.UpdateColumnAt(tableIndex: int, columnIndex: int, header: CompositeHeader, ?cells: CompositeCell []) =
        this.MapTableAt(tableIndex, fun table ->
            table.UpdateColumn(columnIndex, header, ?cells=cells)
        )

    // - Column CRUD API - //
    member this.UpdateColumn(tableName: string, columnIndex: int, header: CompositeHeader, ?cells: CompositeCell []) =
        findIndexByTableName tableName this.Tables
        |> fun tableIndex -> this.UpdateColumnAt(tableIndex, columnIndex, header, ?cells=cells)

    // - Column CRUD API - //
    member this.GetColumnAt(tableIndex: int, columnIndex: int) =
        let table = this.GetTableAt(tableIndex)
        table.GetColumn(columnIndex)

    // - Column CRUD API - //
    member this.GetColumn(tableName: string, columnIndex: int) =
        (findIndexByTableName tableName this.Tables, columnIndex)
        |> this.GetColumnAt

    // - Row CRUD API - //
    member this.AddRowAt(tableIndex:int, ?cells: CompositeCell [], ?rowIndex: int) = 
        this.MapTableAt(tableIndex, fun table ->
            table.AddRow(?cells=cells, ?index=rowIndex)
        )

    // - Row CRUD API - //
    member this.AddRow(tableName: string, ?cells: CompositeCell [], ?rowIndex: int) =
        findIndexByTableName tableName this.Tables
        |> fun i -> this.AddRowAt(i, ?cells=cells, ?rowIndex=rowIndex)

    // - Row CRUD API - //
    member this.RemoveRowAt(tableIndex: int, rowIndex: int) =
        this.MapTableAt(tableIndex, fun table ->
            table.RemoveRow(rowIndex)
        )

    // - Row CRUD API - //
    member this.RemoveRow(tableName: string, rowIndex: int) : unit =
        (findIndexByTableName tableName this.Tables, rowIndex)
        |> this.RemoveRowAt

    // - Row CRUD API - //
    member this.UpdateRowAt(tableIndex: int, rowIndex: int, cells: CompositeCell []) =
        this.MapTableAt(tableIndex, fun table ->
            table.UpdateRow(rowIndex, cells)
        )

    // - Row CRUD API - //
    member this.UpdateRow(tableName: string, rowIndex: int, cells: CompositeCell []) =
        (findIndexByTableName tableName this.Tables, rowIndex, cells)
        |> this.UpdateRowAt

    // - Row CRUD API - //
    member this.GetRowAt(tableIndex: int, rowIndex: int) =
        let table = this.GetTableAt(tableIndex)
        table.GetRow(rowIndex)

    // - Row CRUD API - //
    member this.GetRow(tableName: string, rowIndex: int) =
        (findIndexByTableName tableName this.Tables, rowIndex)
        |> this.GetRowAt

    /// Return a list of all the processes in all the tables.
    member this.GetProcesses() : Process list = 
        this.Tables
        |> Seq.toList
        |> List.collect (fun t -> t.GetProcesses())

    static member ofSeq (tables : ArcTable seq) : ArcTables = 
        tables
        |> ResizeArray
        |> ArcTables

    member this.MoveTable(oldIndex, newIndex) =
        let table = this.GetTableAt(oldIndex)
        this.Tables.RemoveAt(oldIndex)
        this.Tables.Insert(newIndex, table)
        //let updatedOldIndex = if newIndex <= oldIndex then oldIndex + 1 else oldIndex

    /// Create a collection of tables from a list of processes.
    ///
    /// For this, the processes are grouped by nameroot ("nameroot_1", "nameroot_2" ...) or exectued protocol if no name exists
    ///
    /// Then each group is converted to a table with this nameroot as sheetname
    static member fromProcesses (ps : Process list) : ArcTables = 
        ps
        |> ProcessParsing.groupProcesses
        |> List.map (fun (name,ps) ->
            ps
            |> List.collect (fun p -> ProcessParsing.processToRows p)
            |> fun rows -> ProcessParsing.alignByHeaders true rows
            |> fun (headers, rows) -> ArcTable.create(name,headers,rows)
        )
        |> ResizeArray
        |> ArcTables

    static member updateReferenceTablesBySheets (referenceTables : ArcTables,sheetTables : ArcTables,?keepUnusedRefTables : bool) : ArcTables =
        let keepUnusedRefTables = Option.defaultValue false keepUnusedRefTables
        let usedTables = HashSet<string>()
        let referenceTableMap = 
            referenceTables.Tables 
            |> Seq.choose (fun t -> 
                t.TryGetProtocolNameColumn()
                |> Option.map (fun c -> c.Cells.[0].AsFreeText, t)
            ) 
            |> Map.ofSeq
        sheetTables.Tables
        |> Seq.toArray
        |> Array.collect ArcTable.SplitByProtocolREF
        |> Array.map (fun t ->
            let k = 
                t.Headers |> Seq.tryFindIndex (fun x -> x = CompositeHeader.ProtocolREF)
                |> Option.bind (fun i ->
                    t.TryGetCellAt(i,0)                        
                )
                |> Option.bind (fun c -> 
                    if c.AsFreeText = ""then None
                    else Some c.AsFreeText )
                |> Option.defaultValue t.Name
            match Map.tryFind k referenceTableMap with
            | Some rt -> 
                usedTables.Add(k) |> ignore
                let updatedTable = ArcTable.updateReferenceByAnnotationTable rt t
                ArcTable.create(t.Name, updatedTable.Headers, updatedTable.Values)
            | None -> t
        )
        |> Array.groupBy (fun t -> t.Name)
        |> Array.map (fun (_,ts) -> 
            ts
            |> Seq.reduce ArcTable.append
        )
        |> Array.map (fun t -> 
            ArcTableAux.Unchecked.fillMissingCells t.Headers t.Values
            t)
        |> fun s -> 
            if keepUnusedRefTables then
                Seq.append 
                    (referenceTableMap |> Seq.choose (fun (kv) -> if usedTables.Contains kv.Key then None else Some kv.Value))
                    s
            else
                s
        |> ResizeArray        
        |> ArcTables